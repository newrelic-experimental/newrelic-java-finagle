package com.newrelic.instrumentation.finagle.http;

import java.util.logging.Level;

import com.newrelic.agent.bridge.AgentBridge;
import com.newrelic.api.agent.NewRelic;
import com.newrelic.api.agent.Trace;
import com.twitter.finagle.Service;
import com.twitter.finagle.http.Request;
import com.twitter.finagle.http.Response;
import com.twitter.util.Future;

/*
 * Used as a wrapper for any services that need to be report.  
 * Typically this would be for a developer defined service.
 * Reported as a segment in New Relic
 */
public class NewRelicServiceWrapper extends Service<Request, Response> {
	
	// need to retransform the class in order for the @Trace to work.
	private static boolean isTransformed = false;
	// the actual Service object
	Service<Request, Response> delegate = null;
	// if the defined service has a name and/or label use it in naming
	private String label = null;
	
	public void setLabel(String label) {
		NewRelic.getAgent().getLogger().log(Level.FINE,"Added label: {0} to wrapped service {0}", delegate);
		this.label = label;
	}

	public NewRelicServiceWrapper(Service<Request, Response> service) {
		delegate = service;
		// The class is retransformed the first time a wrapper is constructed
		if(!isTransformed) {
			isTransformed = true;
			AgentBridge.instrumentation.retransformUninstrumentedClass(getClass());
		}
		NewRelic.getAgent().getLogger().log(Level.FINE,new Exception("Finagle-Tracing"), "Constructed wrapped service for {0}", service);
	}

	@Override
	@Trace(dispatcher = true)
	public Future<Response> apply(Request request) {
		String segmentName;
		if(label != null) {
			NewRelic.getAgent().getTracedMethod().setMetricName("Custom","Finagle","Service","Start",label);
			segmentName = "Finagle/Service/" + label;
		} else {
			NewRelic.getAgent().getTracedMethod().setMetricName("Custom","Finagle","Service","Start");
			segmentName = "Finagle/Service";
		}
		// Get the future generated by the actual
		Future<Response> future = delegate.apply(request);
		
		// construct holder to hold the segment and is called to end the segment
		NewRelicHolder holder = new NewRelicHolder(segmentName);
		// add functions that are called on success and failure of the future
		return future.onSuccess(new NRSuccessFunction<>(holder)).onFailure(new NRFailureFunction(holder));
	}

}
