package com.newrelic.instrumentation.finagle.core;

import com.newrelic.agent.bridge.AgentBridge;
import com.newrelic.api.agent.NewRelic;
import com.newrelic.api.agent.Trace;
import com.twitter.finagle.Service;
import com.twitter.util.Future;

/*
 * Used as a wrapper for any services that need to be report.  
 * Typically this would be for a developer defined service.
 * Reported as a segment in New Relic
 */
public class NewRelicServiceWrapper<Req, Rep> extends Service<Req, Rep> {
	
	// need to retransform the class in order for the @Trace to work.
	private static boolean isTransformed = false;
	// the actual Service object
	Service<Req,Rep> delegate = null;
	// if the defined service has a name and/or label use it in naming
	private String label = null;
	
	public void setLabel(String label) {
		this.label = label;
	}

	public NewRelicServiceWrapper(Service<Req,Rep> service) {
		delegate = service;
		// The class is retransformed the first time a wrapper is constructed
		if(!isTransformed) {
			isTransformed = true;
			AgentBridge.instrumentation.retransformUninstrumentedClass(getClass());
		}
	}

	@Override
	@Trace(dispatcher = true)
	public Future<Rep> apply(Req request) {
		String segmentName;
		if(label != null) {
			NewRelic.getAgent().getTracedMethod().setMetricName("Custom","Finagle","Service","Start",label);
			segmentName = "Finagle/Service/" + label;
		} else {
			NewRelic.getAgent().getTracedMethod().setMetricName("Custom","Finagle","Service","Start");
			segmentName = "Finagle/Service";
		}
		// Get the future generated by the actual
		Future<Rep> future = delegate.apply(request);
		
		// construct holder to hold the segment and is called to end the segment
		NewRelicHolder holder = new NewRelicHolder(segmentName);
		// add functions that are called on success and failure of the future
		return future.onSuccess(new NRSuccessFunction<>(holder)).onFailure(new NRFailureFunction(holder));
	}

}
